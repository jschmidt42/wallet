#!/bin/bash

#
# Copyright 2022-2023 Wiimag Inc. All rights reserved.
# License: https://equals-forty-two.com/LICENSE
#
# Run script to execute most common operations used when working on the application framework.
#

APP_NAME=Wallet
SHORT_NAME=$(basename $(git rev-parse --show-toplevel))

SOLUTION_DIR=projects/.build

bold=$(tput bold)
normal=$(tput sgr0)
progname=$(basename $0)
unameOut="$(uname -s)"
green='\033[0;32m'
dark_gray='\033[1;30m'
light_gray='\033[0;37m'
red='\033[0;31m'
yellow='\033[1;33m'
blue='\033[0;34m'
purple='\033[0;35m'
cyan='\033[0;36m'
white='\033[1;37m'
nc='\033[0m' # No Color
italic=$(tput sitm)
underline=$(tput smul)
reset=$(tput sgr0)

# Determine running platform
case "${unameOut}" in
    Linux*)     machine=Linux;;
    Darwin*)    machine=Mac;;
    CYGWIN*)    machine=Cygwin;;
    MINGW*)     machine=MinGw;;   # i.e. running from git bash
    *)          machine="UNKNOWN:${unameOut}"
esac

# Determine if we are running on a mac
if [ $machine = "Mac" ]; then
  PLATFORM_MAC=1
else
  PLATFORM_MAC=0
fi

# Determine if we are running on a linux
if [ $machine = "Linux" ]; then
  PLATFORM_LINUX=1
else
  PLATFORM_LINUX=0
fi

# Determine if we are running on a windows
if [ $machine = "Cygwin" ] || [ $machine = "MinGw" ]; then
  PLATFORM_WINDOWS=1
else
  PLATFORM_WINDOWS=0
fi

is_number() { 
  [ "$1" ] && [ -z "${1//[0-9]}" ] ;
}

function convert_path_to_platform() {
  if [ $PLATFORM_WINDOWS -eq 1 ]; then
    win_path=$(cygpath -w "$1")
    # Replace all \ with / in the path
    echo "${win_path//\\/\/}"
  else
    echo "$1"
  fi
}

function convert_path_to_file_link() {
  local_path=$(convert_path_to_platform $1)
  if [ $machine = "MinGw" ]; then
    echo "file:///${local_path//\\/\/}"
  else
    echo "$1"
  fi
}


# Precompute some paths
FULL_SOLUTION_DIR=$(convert_path_to_platform $(pwd)/$SOLUTION_DIR)

#
# Parse common command line arguments
#

POSITIONAL_ARGS=()
RUN=1 # Indicate if the default build should be run at the end
BUILD=0
BUILD_DEBUG=0
BUILD_RELEASE=1
BUILD_DEPLOY=0
TESTS=0
OPEN=0
OPEN_WORKSPACE=0
GENERATE=0
GENERATED=0
START=0
PRINT=0
PRINT_LARGEFILES=0
HELP=0
VERBOSE=0
DIFF=0

COMMAND_COUNTER=0

# Check if project/.build is present, if not, then we need to generate the project
# Also check if the project/.build/CMakeCache.txt is present, if not, then we need to generate the project
if [ ! -d "$SOLUTION_DIR" ] || [ ! -f "$SOLUTION_DIR/CMakeCache.txt" ]; then
  BUILD=1
  GENERATE=1

  # If there is not arguments to ./run, then lets force start to be the default command
  if [ $COMMAND_COUNTER -eq 0 ]; then
    START=1
  fi
fi

while [[ $# -gt 0 ]]; do
  #echo "\$1:\"$1\" \$2:\"$2\""
  case $1 in
    -h|--help)
      HELP=1
      shift # past argument
      ;;
    --verbose)
      VERBOSE=1
      POSITIONAL_ARGS+=("$1") # save positional arg
      shift # past argument
      ;;
    -n|--name)
      SHORT_NAME="$2"
      shift # past argument
      shift # past value
      ;;
    -a|--app-name)
      APP_NAME="$2"
      shift # past argument
      shift # past value
      ;;
    b|build)
      # Update the command counter
      COMMAND_COUNTER=$((COMMAND_COUNTER+1))
      BUILD=$COMMAND_COUNTER
      shift # past argument

      # The release argument is the default, but remove it if it was specified
      if [ $# -ne 0 ] && [ $1 = "release" ]; then
        BUILD_RELEASE=1
        shift
      fi

      if [ $# -ne 0 ] && [ $1 = "debug" ]; then
        BUILD_DEBUG=1
        shift
      fi

      if [ $# -ne 0 ] && [ $1 = "deploy" ]; then
        BUILD_DEPLOY=1
        shift
      fi

      ;;
    p|print)
      COMMAND_COUNTER=$((COMMAND_COUNTER+1))
      PRINT=$COMMAND_COUNTER
      shift # past argument

      # The release argument is the default, but remove it if it was specified
      if [ $# -ne 0 ] && [ $1 = "largefiles" ]; then
        PRINT_LARGEFILES=1
        shift
      fi
      ;;
    g|generate)
      COMMAND_COUNTER=$((COMMAND_COUNTER+1))
      GENERATE=$COMMAND_COUNTER
      shift # past argument
      ;;  
    o|open)
      COMMAND_COUNTER=$((COMMAND_COUNTER+1))
      OPEN=$COMMAND_COUNTER
      shift # past argument

      # Check if we open the workspace or the cmake generated solution
      if [ $# -ne 0 ] && ([ $1 == "workspace" ] || [ $1 == "w" ]); then
        
        # Always generate the project if we are opening the workspace
        GENERATE=1
        OPEN_WORKSPACE=1
        shift
      fi

      ;;
    t|tests)
      COMMAND_COUNTER=$((COMMAND_COUNTER+1))
      TESTS=$COMMAND_COUNTER
      shift # past argument
      ;;
    d|diff)
      COMMAND_COUNTER=$((COMMAND_COUNTER+1))
      DIFF=$COMMAND_COUNTER
      shift # past argument
      ;;
    s|start)
      COMMAND_COUNTER=$((COMMAND_COUNTER+1))
      START=$COMMAND_COUNTER
      RUN=1

      shift # past argument
      ;;
    *)
      POSITIONAL_ARGS+=("$1") # save positional arg
      shift # past argument
      ;;
  esac
done

#
# Check if help was requested
#
if [ $HELP -ge 1 ]; then

  echo "  Usage: $progname [${bold}b${normal}uild [debug|release|deploy]] "
  echo "             [${bold}g${normal}enerate] "
  echo "             [${bold}t${normal}ests] " 
  echo "             [${bold}o${normal}pen [${bold}w${normal}orkspace]] "
  echo "             [${bold}p${normal}rint [largefiles] "
  echo "             [${bold}d${normal}iff [main|release/1.0.0|...] "
  echo "             [${bold}s${normal}tart] [--option=<value>] ...additional arguments passed to last command"
  echo ""
  echo "  Commands:"
  echo "    ${bold}b${normal}uild [debug|release]  Build the solution in debug or release (release if used by default)"
  echo "    ${bold}g${normal}enerate               Generate the solution (i.e. using CMake)"
  echo "    ${bold}t${normal}ests                  Run application tests (i.e. using --run-tests)"
  echo "    ${bold}o${normal}pen [workspace]       Open the application solution workspace (i.e. Visual Studio or Xcode IDE)"
  echo "    ${bold}p${normal}rint [largefiles|...] Print various solution information or stats"
  echo "    ${bold}d${normal}iff [...]             Diff the current branch with the specified remote branch (i.e. main, release/1.0.0, etc.)"
  echo "    ${bold}s${normal}tart                  Launch the application after running other commands "
  echo ""
  echo "    If no commands are specified, we start the application by default, i.e. './run')"
  echo ""
  echo "    Commands can be chained one after the other, i.e. './run build tests --success=true --verbose'"
  echo ""
  echo "  Optional arguments:"
  echo "   -h, --help            Show this help message and exit"
  echo "   -n, --name <name>     Specify the solution name (used to open the workspace are launch the exe on Windows)"
  echo "   -a, --app-name <name> Specify the App name to launch application on MacOS"
  echo "   --verbose             Increase the verbosity of the bash script"
  echo ""
  echo "  Examples:"
  echo "    ./run build                         Build the solution"
  echo "    ./run build tests start             Build then run tests and finally lanch the application"
  echo "    ./run build tests --success=true    Build then run tests passing the --success=true argument to test framework"
  echo "    ./run print largefiles 50           Print top 50 largest files in the repo."
  echo "    ./run diff                          Diff the current branch with the main branch (default)"
  echo "    ./run diff release/1.0              Diff the current branch with the remote release 1.0 branch"
  echo "    ./run generate open cmake           Generate and open the generated cmake solution"
  echo ""
  exit 0

fi

if [ $VERBOSE -ge 1 ]; then

  # Print all set variables
  echo "APP_NAME: $APP_NAME"
  echo "SHORT_NAME: $SHORT_NAME"
  echo "BUILD: $BUILD"
  echo "  BUILD_DEBUG: $BUILD_DEBUG"
  echo "  BUILD_RELEASE: $BUILD_RELEASE"
  echo "  BUILD_DEPLOY: $BUILD_DEPLOY"
  echo "OPEN: $OPEN"
  echo "  OPEN_WORKSPACE: $OPEN_WORKSPACE"
  echo "GENERATE: $GENERATE"
  echo "PRINT: $PRINT"
  echo "  PRINT_LARGEFILES: $PRINT_LARGEFILES"
  echo "TESTS: $TESTS"
  echo "DIFF: $DIFF"
  echo "START: $START"
  echo "HELP: $HELP"
  echo "VERBOSE: $VERBOSE"

  # Echo positional args
  echo "Positional arguments: ${POSITIONAL_ARGS[@]}"
fi

#
# Generate the CMAKE solution
#
if [ $GENERATE -ge 1 ]; then

  echo 
  echo -e "${green}Generating solution...${normal}"
  echo

  # Create the build directory if it doesn't exist and ignore any errors
  mkdir -p $SOLUTION_DIR 2>/dev/null
  cd $SOLUTION_DIR

  CMAKE_ARGS=()
  if [ $GENERATE -eq $COMMAND_COUNTER ]; then
    CMAKE_ARGS=(${POSITIONAL_ARGS[@]})
  fi

  # If verbose is enabled add -DBUILD_INFO=ON to the cmake command
  if [ $VERBOSE -ge 1 ]; then
    CMAKE_ARGS+=("-DBUILD_INFO=ON")
  else
    CMAKE_ARGS+=("-DBUILD_INFO=OFF")
  fi

  if [ $machine == "MinGw" ]; then
    cmake -G "Visual Studio 17 2022" -A x64 ../.. ${CMAKE_ARGS[@]}
  elif [ ${machine} == "Mac" ]; then
    cmake -G "Xcode" ../.. ${CMAKE_ARGS[@]}
  fi

  retval=$?
  if [ $retval -ne 0 ]; then
    echo
    echo -e "${red}===GENERATE FAILED ($retval)===${normal}"
    echo
    exit $retval
  fi

  # Keep track of it the solution was generated or not.
  # We will use this to determine if we need to build the solution or not.
  GENERATED=1
  cd ../../

  # Print the path of the generated solution
  echo
  echo -e "${dark_gray}Solution generated at: ${normal}$(convert_path_to_file_link $FULL_SOLUTION_DIR)"

  # Skip running the applicatin by default since we just generated the solution
  RUN=0
fi

#
# Build solution
#
if [ $BUILD -ge 1 ]; then

  # Print building message in green
  echo 
  echo -e "${green}Building solution...${normal}"
  echo

  cd $SOLUTION_DIR

  CMAKE_ARGS=()

  if [ $machine == "MinGw" ]; then
    # Append /verbosity and /filelogger to output build results to ../../artifacts/cmake-build.log
    if [ $VERBOSE -eq 1 ]; then
      CMAKE_ARGS+=("/verbosity:detailed")
    fi
    CMAKE_ARGS+=("-fileLogger")
    CMAKE_ARGS+=("-fileLoggerParameters:logfile=cmake-build.log;verbosity=Normal")
  fi

  ADDITIONAL_ARGS=()
  if [ $BUILD -eq $COMMAND_COUNTER ]; then
    ADDITIONAL_ARGS=(${POSITIONAL_ARGS[@]})
  fi

  if [ $BUILD_DEBUG -eq 1 ]; then
    cmake --build . --parallel 7 --config Debug ${ADDITIONAL_ARGS[@]} -- ${CMAKE_ARGS[@]}
  elif  [ $BUILD_DEPLOY -eq 1 ]; then
    cmake --build . --parallel 7 --config Deploy ${ADDITIONAL_ARGS[@]} -- ${CMAKE_ARGS[@]}
  else
    cmake --build . --parallel 7 --config Release ${ADDITIONAL_ARGS[@]} -- ${CMAKE_ARGS[@]}
  fi

  retval=$?
  if [ $retval -ne 0 ]; then
    echo
    echo -e "${red}===BUILD FAILED ($retval)===${normal}"
    echo
    exit $retval
  fi

  BUILD_LOG_PATH=$(convert_path_to_platform $FULL_SOLUTION_DIR/cmake-build.log)
  echo
  echo -e "${dark_gray}Build log: ${normal}$(convert_path_to_file_link $BUILD_LOG_PATH)"
  
  cd ../../
  RUN=0
fi

#
# GIT DIFF
#
if [ $DIFF -ge 1 ]; then

  # Check if we have a remote branch to diff against and make sure the argument doesn't start with -- or -
  if [ ${#POSITIONAL_ARGS[@]} -eq 0 ] || [[ ${POSITIONAL_ARGS[0]} == --* ]] || [[ ${POSITIONAL_ARGS[0]} == -* ]]; then
    # Insert main at position 0 and push other arguments
    POSITIONAL_ARGS=("${POSITIONAL_ARGS[@]:0:0}" "main" "${POSITIONAL_ARGS[@]:0}")
  fi
  
  # Diff the current branch with the specified remote branch
  git difftool -d "origin/${POSITIONAL_ARGS[0]}" ${POSITIONAL_ARGS[@]:1}

  # Check return value
  retval=$?
  if [ $retval -ne 0 ]; then
    echo
    echo -e "${red}===DIFF FAILED ($retval)===${normal}"
    echo
    exit $retval
  fi

  RUN=0
fi

#
# Open IDE
#
if [ $OPEN -ge 1 ]; then

  echo 
  echo -e "${green}Opening IDE...${normal}"
  echo

  if [ $OPEN_WORKSPACE -eq 1 ]; then

    if [ $machine == "MinGw" ]; then
      start $SOLUTION_DIR/${SHORT_NAME}.sln
    elif [ ${machine} == "Mac" ]; then
      open $SOLUTION_DIR/${SHORT_NAME}.xcodeproj
    fi

    retval=$?
    if [ $retval -ne 0 ]; then
      echo
      echo -e "${red}===OPEN WORKSPACE FAILED ($retval)===${normal}"
      echo
      exit $retval
    fi

    RUN=0
  fi
fi

#
# Print various solution information
#
if [ $PRINT -ge 1 ]; then

  if [ $PRINT_LARGEFILES -eq 1 ]; then

    TOP_COUNT=20
    if is_number ${POSITIONAL_ARGS[0]}; then
      TOP_COUNT=${POSITIONAL_ARGS[0]}
    fi

    while read -r largefile; do
      echo $largefile | awk '{printf "%s %s ", $1, $3 ; system("git rev-list --all --objects | grep " $1 " | cut -d \" \" -f 2-")}'
    done <<< "$(git rev-list --all --objects | awk '{print $1}' | git cat-file --batch-check | sort -k3nr | head -n $TOP_COUNT)"

    retval=$?
    if [ $retval -ne 0 ]; then
      echo
      echo -e "${red}===PRINT LARGEFILES FAILED ($retval)===${normal}"
      echo
      exit $retval
    fi

    RUN=0
  fi
fi

#
# Run tests
#
if [ $TESTS -ge 1 ]; then

  echo 
  echo -e "${green}Running tests...${normal}"
  echo

  ADDITIONAL_ARGS=()
  if [ $TESTS -eq $COMMAND_COUNTER ]; then
    ADDITIONAL_ARGS=(${POSITIONAL_ARGS[@]})
  fi

  if [ ${machine} == "MinGw" ]; then
    ./build/${SHORT_NAME}.exe --run-tests ${ADDITIONAL_ARGS[@]}
  elif [ ${machine} == "Mac" ]; then
    ./build/${APP_NAME}.app/Contents/MacOS/${APP_NAME} --run-tests ${ADDITIONAL_ARGS[@]}
  fi

  retval=$?
  if [ $retval -ne 0 ]; then
    echo
    echo -e "${red}===TESTS FAILED ($retval)===${normal}"
    echo
    cat artifacts/tests.log
    exit $retval
  fi

  # Print building message in green
  echo 
  echo -e "${green}===TESTS SUCCESSED===${normal}"
  echo
  
  # Print test results
  cat artifacts/tests.log

  RUN=0
fi

# Check if we have an explicit command to run/start the application
if [ $START -ge 1 ]; then
  RUN=1
fi

# Finally run the application if requested.
if [ $RUN -eq 1 ]; then

  echo 
  echo -e "${green}${italic}Running ${APP_NAME}...${normal}"
  echo

  if [ ${machine} == "MinGw" ]; then
    ./build/${SHORT_NAME}.exe ${POSITIONAL_ARGS[@]}
  elif [ ${machine} == "Mac" ]; then
    ./build/${APP_NAME}.app/Contents/MacOS/${APP_NAME} ${POSITIONAL_ARGS[@]}
  fi

  retval=$?
  if [ $retval -ne 0 ]; then
    echo
    echo "${red}===RUN FAILED ($retval)===${normal}"
    echo
    exit $retval
  fi
fi

echo
exit $?
